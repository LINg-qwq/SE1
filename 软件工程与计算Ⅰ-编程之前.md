# 软件工程与计算Ⅰ -编程之前

> 本部分内容对应于PPT 01-05

## 编程语言概述

这部分内容已经大量包括在名词解释那个文档中，因而此处略去了大部分内容。

50年代：机器语言

60年代：汇编语言

- 1968 – Logo

- 1969 – B (forerunner to C)
- 1970 – Pascal
- 1970 – Forth
- 1972 – C-（结构化编程范式）
- 1972 – Smalltalk（面向对象编程范式）
- 1972 – Prolog（逻辑编程范式）
- 1975 – Scheme（函数式编程范式）
- 1978 – SQL （标准查询语言）
- 1980 – C++ (原C with classes, 1983改用现名)
- 1984 – MATLAB
- 1986 – Objective-C
- 1988 – Wolfram Language
- 1990 – Haskell
- 1991 – Python
- 1991 – Visual Basic
- 1993 – Ruby
- 1995 – Java

后面的应该也太新了，就不管了。老师上课还提到了Oracle和Google的斗争：抄API到底算不算侵权？

## 分解与抽象

编程的典型场景 — 数据处理：输入处理输出

### 可计算性

莱布尼兹→推理演算，布尔→布尔代数，弗雷格→数理逻辑，康托尔→⽆穷集和对⻆线法

#### 罗素悖论（关联希尔伯特判定问题）

理发师悖论：A={x|x ∉ x}时，A∈A是否成立？

#### 停机问题

不存在这样⼀个程序（算法），它能够计算任何程序（算法）在给定输⼊上是否会结束（停机）。

只要有⼀个数学问题可以被证明在算法上试不可解的，那么判定问题本身就必定不可解。

- “找到⼀种算法，判定⼀个给定的⾃然数是否属于集合D。”这个问题就是⼀个不可解问题的例⼦。
-  假设存在这样的算法，则存在这样的图灵机
-  把输⼊的数属于D ，那么按以前运转，否则将永远右移（2个五元组即可表达）
-  新机器的停机集合就是D。然⽽这时不可能的。

对⻆线⽅法将允许我们构造出⼀个与图灵机的任何停机集合都不同的⾃然数集合。

> 证明实数不可数的过程也类似于此。

```c++
bool God_algo(char* program, char* input){
	if(<program> halts on <input>){return true;}
	else{return false;}}
```

```c++
bool Satan_algo(char* program){
	if( God_algo(program, program) ){
		while(1); // loop forever!
		return false; // can never get here!}
	else{
	return true;}}
```

- Satan_algo(Satan_algo)能够停机 => 它不能停机

- Satan_algo(Satan_algo)不能停机 => 它能够停机

#### 哥德尔不完备性定理

> 哥德尔：弗雷格的规则是完备的。

任何相容的形式系统，只要蕴涵⽪亚诺算术公理，就可以在其中构造在体系中既不能证明也不能否证的命题（即体系是不完备的）

任何相容的形式系统，只要蕴涵⽪亚诺算术公理，它就不能⽤于证明它本身的相容性。

> Trick：你可以用外部的形式系统证明它的相容性
>
> 只需在假定的形式系统T内表达出⼀个为真但⽆法在T内推导出（证明）的命题。P：P不可在系统T内证明→P为真但⽆法在T内推导出来→T不可以证明出P （存在不能证明的）

#### 邱奇-图灵论题



## Lambda演算

这部分内容就没有比老师给的那两个文档讲的更好的了，建议细看，这里只是总结几个老师的例题。