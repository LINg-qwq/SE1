# 软件工程与计算Ⅰ -编程之前

> 本部分内容对应于PPT 01-05

## 编程语言概述

这部分内容已经大量包括在名词解释那个文档中，因而此处略去了大部分内容。

50年代：机器语言

60年代：汇编语言

> - 1968 – Logo
>
> - 1969 – B (forerunner to C)
> - 1970 – Pascal
> - 1970 – Forth
> - 1972 – C-（结构化编程范式）
> - 1972 – Smalltalk（面向对象编程范式）
> - 1972 – Prolog（逻辑编程范式）
> - 1975 – Scheme（函数式编程范式）
> - 1978 – SQL （标准查询语言）
> - 1980 – C++ (原C with classes, 1983改用现名)
> - 1984 – MATLAB
> - 1986 – Objective-C
> - 1988 – Wolfram Language
> - 1990 – Haskell
> - 1991 – Python
> - 1991 – Visual Basic
> - 1993 – Ruby
> - 1995 – Java

后面的应该也太新了，就不管了。老师上课还提到了Oracle和Google的斗争：抄API到底算不算侵权？

## 分解与抽象

编程的典型场景 — 数据处理：输入处理输出

### 可计算性

> 此处的可计算性仅仅考虑在理论上是否可以计算而不考虑现实中成本的制约

莱布尼兹→推理演算，布尔→布尔代数，弗雷格→数理逻辑，康托尔→⽆穷集和对⻆线法

#### 罗素悖论（关联希尔伯特判定问题）

理发师悖论：A={x|x ∉ x}时，A∈A是否成立？

#### 停机问题

不存在这样⼀个程序（算法），它能够计算任何程序（算法）在给定输⼊上是否会结束（停机）。

只要有⼀个数学问题可以被证明在算法上试不可解的，那么判定问题本身就必定不可解。

- “找到⼀种算法，判定⼀个给定的⾃然数是否属于集合D。”这个问题就是⼀个不可解问题的例⼦。
-  假设存在这样的算法，则存在这样的图灵机
-  把输⼊的数属于D ，那么按以前运转，否则将永远右移（2个五元组即可表达）
-  新机器的停机集合就是D。然⽽这时不可能的。

对⻆线⽅法将允许我们构造出⼀个与图灵机的任何停机集合都不同的⾃然数集合。

> 证明实数不可数的过程也类似于此。

```c++
bool God_algo(char* program, char* input){
	if(<program> halts on <input>){return true;}
	else{return false;}}
```

```c++
bool Satan_algo(char* program){
	if( God_algo(program, program) ){
		while(1); // loop forever!
		return false; // can never get here!}
	else{
	return true;}}
```

- Satan_algo(Satan_algo)能够停机 => 它不能停机

- Satan_algo(Satan_algo)不能停机 => 它能够停机

#### 哥德尔不完备性定理

> 哥德尔：弗雷格的规则是完备的。

任何相容的形式系统，只要蕴涵⽪亚诺算术公理，就可以在其中构造在体系中既不能证明也不能否证的命题（即体系是不完备的）

任何相容的形式系统，只要蕴涵⽪亚诺算术公理，它就不能⽤于证明它本身的相容性。

> Trick：你可以用外部的形式系统证明它的相容性
>
> 只需在假定的形式系统T内表达出⼀个为真但⽆法在T内推导出（证明）的命题。P：P不可在系统T内证明→P为真但⽆法在T内推导出来→T不可以证明出P （存在不能证明的）

#### 邱奇-图灵论题

- ⼀台图灵机单凭⾃身就可以完成任何图灵机可能做到的任何事情。

- 图灵提出了机器、程序、数据观念的融合与替换。
- 任何有对应算法的函数都是可计算的。
- All three computational processes (recursion, the λ-calculus, and the Turing machine) were shown to be equivalent.

##### 非形式化

> - i) 1是⾃然数；
>
> - ii) 每⼀个确定的⾃然数a，都有⼀个确定的后继数a' ，a' 也是⾃然数（⼀个数的后继数就是紧接在这个数后⾯的数）；
>
> - iii) 如果⾃然数b、c的后继数都是⾃然数a，那么b = c；
>
> - iv) 1不是任何⾃然数的后继数；
>
> - v) 任意关于⾃然数的命题，如果证明了它对⾃然数1是对的，⼜假定它对⾃然数n为真时，可以证它对n' 也真，那么，命题对所有⾃然数都真。（这条公理保证了数学归纳法的正确性）

> 若将0也视作⾃然数，则公理中的1要换成0。

##### 形式化

> 三元组（X, x, f）
>
> • X是⼀集合，x为X中⼀元素，f是X到⾃身的映射。
>
> • x不在f的值域内。（对应上⾯的公理4）
>
> • f为⼀单射。（对应上⾯的公理3）
>
> • 若A为X的⼦集并满⾜：
>
> • x属于A,且若a属于A，则f（a） 亦属于A，则A = X。

⼀切初等数论中的函数都可以由原始递归式作出，即都是原始递归函数。

μ-递归函数以后的数论内容此处略去。

##### 图灵机

![image-20200820194931403](https://oss.ydjsir.com.cn/img/turingMachine.png)

这部分内容如果想深入了解的话可以好好看看离散数学教材的第十一章：有限状态机。

下面是一个`f(x) = 2^x` 的函数的图灵机表达形式。这里用了五元组的表达形式，而略去了q~reject~ 和 q~accept~ 。

![image-20200820195546105](https://oss.ydjsir.com.cn/img/image-20200820195546105.png)

###### 约定

- 1.开始时，纸带上只有⼀连续的⽅格串上放⼊相应于x的⼆进制值的符号，其余⽅格均为空⽩（⽤B表示）；
- 2.读写头⼀开始位于表示x的⽅格的最左边⼀位所在⽅格；
- 3.停机时，纸带上⾮空⽅格串所组成的⼆进制值即为所求结果。
###### 程序的实现思想：
  我们知道，在⼆进制表示下，只要在原数后⾯添上⼀个0，就是原来的数乘以⼆。根据这个思想，我们每次写⼀个0，同时原数减⼀，直到原数减为0，再在所写的0前⾯添加上⼀个1，就能得出所求函数的答案了。
  ###### 状态含义：
  • q1:起始状态；忽略前导0，寻找该数的真正起始位置，如果出现_00……00_0…… 00的情况，则转⼊q7；

  • q2:读写头向右移动直到遇到空格；

  • q3: 此空格后0的数⽬加1；

  • q4:回到原来数的最右端；

  • q5: 该数减1；

  • q6: 回到数的开头，转⼊q1；

  • q7:结束状态。

  可以看到，q1到q7,7个状态，相当于⼀个个标志，而整个程序也相当于是⼀句句的goto语句。

这里可以再补充一个例子。这个例子是`f(x) = x + 1` 。

| 图灵机对应五元组 | 备注                                         |
| ---------------- | -------------------------------------------- |
| q1,0,1,l,q2      | 末尾是0的话，就把末尾改为1                   |
| q1,1,0,l,q3      | 末尾是1的话，就把末尾改为0，并进入q2进位模式 |
| q1,b,b,n,q4      | 如果根本没有读到数字，直接跳到q4，结束循环   |
| q2,0,0,l,q2      | 只要当前不为空，读取头就继续左移             |
| q2,1,1,l,q2      | 只要当前不为空，读取头就继续左移             |
| q2,b,b,n,q4      | 一旦读取到空内容，直接跳到q4，结束循环       |
| q3,0,1,l,q2      | 进位后若不需要继续进位，跳到q2               |
| q3,1,0,l,q3      | 进位后仍需继续进位                           |
| q3,b,b,n,q4      | 一旦读取到空内容，直接跳到q4，结束循环       |

> 读写头⼀开始位于数据最右边⼀位，b表示空格，q1为初始状态，q4为结束状态。q2为不进位情况下读取头不断左移的状态，q3是进位状态。可以回顾计基中的全加法器，这两个是类似的。

![image-20200820201202995](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97%E2%85%A0-%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%89%8D.assets/image-20200820201202995.png)

 图灵机 对应 寄存器机部分内容此处从略。

![image-20200820202212310](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97%E2%85%A0-%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%89%8D.assets/image-20200820202212310.png)

对每一个图灵机T而言，一定有一个寄存器机器R和T具有相同的行为，且这个寄存器机器最少包括两个寄存器和两条指令。

## Lambda演算

这部分内容就没有比老师给的那两个文档讲的更好的了，建议细看，这里只是总结几个老师的例题和一些漏掉的点。

> BNF记号与上下文无关语法的详细内容可以在离散数学教材中获得参考。

形式化地，我们从⼀个标识符（identifier）的可数⽆穷集合开始，⽐如{a, b, c, ..., x, y, z, x1, x2, ...}，则所有的lambda表达式可以通过下述以BNF范式表达的上下⽂⽆关⽂法描述：

> -  <表达式> ::= <标识符>
> -  <表达式> ::=(λ<标识符> .<表达式>)
> -  <表达式> ::=(<表达式> <表达式>)

头两条规则⽤来⽣成函数，⽽第三条描述了函数是如何作⽤在参数上的。

